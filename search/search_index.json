{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Find security vulnerabilities, compliance issues, and infrastructure misconfigurations early in the development cycle of your infrastructure-as-code with KICS by Checkmarx. KICS stands for K eeping I nfrastructure as C ode S ecure, it is open source and is a must-have for any cloud native project. Version 1.1.4 2021.02.24 Downloads: Windows Linux MacOS Contribute! Supported Platforms KICS scans and detects issues in following Infrastructure as Code solutions: Support of other solutions, such as Chef, and of additional cloud providers are on the roadmap . Getting Started Setting up and using KICS is super-easy. First, see how to install and get KICS running . Then explore KICS output results format and quickly fix the issues detected. Interested in more advanced stuff? - Deep dive into KICS queries . - Understand how you to integrate KICS in your favourit CI/CD pipelines. How it Works What makes KICS really powerful and popular is its built-in extensibility. This extensibility is achieved by: Fully customizable and adjustable heuristics rules, called queries . These can be easily edited, extended and added. Robust but yet simple architecture , which allows quick addition of support for new Infrastructure as Code solutions. Contribution KICS is a true community project. It's built as an open source project from day one and anyone can find his own way to contribute to the project. Check out how , within just minutes, you can start making a difference, by sharing your expertise with a community of thousands of security experts and software developers. How can I help?! Take me to the repo on GitHub! About the Project The KICS project is powered by Checkmarx , global leader of Application Security Testing. Read more about Infrastructure as Code , Infrastructure as Code Testing and Checkmarx. KICS will always stay an open source and free project for the benefit of global software industry community. We believe that when Software is Everywhere, Security is Everything . Now, Software = Security . Looking for more info? Explore KICS project in details: Roadmap Project plans Issues Join the chat on Gitter . Or contact KICS core team at kics@checkmarx.com","title":"Home"},{"location":"#supported-platforms","text":"KICS scans and detects issues in following Infrastructure as Code solutions: Support of other solutions, such as Chef, and of additional cloud providers are on the roadmap .","title":"Supported Platforms"},{"location":"#getting-started","text":"Setting up and using KICS is super-easy. First, see how to install and get KICS running . Then explore KICS output results format and quickly fix the issues detected. Interested in more advanced stuff? - Deep dive into KICS queries . - Understand how you to integrate KICS in your favourit CI/CD pipelines.","title":"Getting Started"},{"location":"#how-it-works","text":"What makes KICS really powerful and popular is its built-in extensibility. This extensibility is achieved by: Fully customizable and adjustable heuristics rules, called queries . These can be easily edited, extended and added. Robust but yet simple architecture , which allows quick addition of support for new Infrastructure as Code solutions.","title":"How it Works"},{"location":"#contribution","text":"KICS is a true community project. It's built as an open source project from day one and anyone can find his own way to contribute to the project. Check out how , within just minutes, you can start making a difference, by sharing your expertise with a community of thousands of security experts and software developers. How can I help?! Take me to the repo on GitHub!","title":"Contribution"},{"location":"#about-the-project","text":"The KICS project is powered by Checkmarx , global leader of Application Security Testing. Read more about Infrastructure as Code , Infrastructure as Code Testing and Checkmarx. KICS will always stay an open source and free project for the benefit of global software industry community. We believe that when Software is Everywhere, Security is Everything . Now, Software = Security . Looking for more info? Explore KICS project in details: Roadmap Project plans Issues Join the chat on Gitter . Or contact KICS core team at kics@checkmarx.com","title":"About the Project"},{"location":"CONTRIBUTING/","text":"Contribution We would like to THANK YOU for considering contributing to KICS! KICS is a true community project. It's built as an open source from day one, and anyone can find his own way to contribute to the project. Within just minutes, you can start making a difference, by sharing your expertise with a community of thousands of security experts and software developers. Contribution Options Good news! You don't have to contribute code. There are plenty of ways you can contribute to KICS project: Reporting new bugs or issues Help triaging issues Improving and translating the documentation Volunteering to maintain the project Code of Conduct By participating and contributing to the project, you agree to uphold our Code of Conduct . Get Started! Follow the instructions below to setup local KICS development environment and push your changes. Fork the kics repo on GitHub. Clone your fork locally: git clone https://github.com/Checkmarx/kics.git Create a branch for local development. Use succinct but descriptive name (prefix with feature/issue#-descriptive-name> or hotfix/issue#-descriptive-name ): git checkout -b <name-of-your-issue> Make your changes locally. Validate your changes to reassure they meet project quality and contribution standards: golint . go mod vendor go test -mod=vendor -v ./... Commit your changes and push your branch to GitHub: git add . git commit git push --set-upstream origin <name-of-your-issue> Submit a pull request on GitHub website. How to Contribute Contributions are made to this repo via Issues and Pull Requests (PRs). A few general guidelines that cover both: Search for existing issues and pull requests before creating your own to avoid duplicates. PRs will only be accepted if associated with an issue (enhancement or bug) that has been submitted and reviewed/labeled as accepted . We will work hard to make sure issues that are raised are handled in a timely manner. Issues Issues should be used to report problems with the solution / source code, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help by indicating to our maintainers that a particular problem is affecting more than just the reporter. Pull Requests Pull Requests (PRs) are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix/add the functionality in question or address code style issues, not both. Ensure all necessary details are provided and adhered to. Add unit or integration tests for fixed or changed functionality (if a test suite already exists) or specify steps taken to ensure changes were tested and functionality works as expected. Address a single concern in the least number of changed lines as possible. Include documentation in the repo or Provide additional comments in Markdown comments that should be pulled/reflected in GitHub Wiki for the given project. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), please open an Issue to discuss your proposal first. Pull Request Guidelines Before you submit a pull request, please reassure that it meets these guidelines: All validations and tests passed locally. The pull request includes tests. The relevant docs are updated, whether you're pushing new functionality or updating a query. Templates The following templates will be used when creating a new issue : Enhancement/Feature Request Template New (Approved) Feature Template Query Template Bug Report Template Resources How to Contribute to Open Source Using Pull Requests GitHub Help Join the chat on Gitter . Or contact KICS core team at kics@checkmarx.com And become one of our top contributors! Top Contributors Special thanks to Lior Kaplan from Kaplan Open Source Consulting for his assistance in creating KICS. The people listed below had made a huge contribution to KICS. Ruben Silva Rafaela Soares Jo\u00e3o Martins Joel Carvalho Pedro Mimoso Nuno Ara\u00fajo F\u00e1bio Gon\u00e7alves Mariana Carvalho Jorge Cruz Jo\u00e3o Oliveira Diogo Lemos Alex Roichman Adar Weidman Eli Trop Joel Sousa S\u00f3nia Ant\u00e3o Catarina Ara\u00fajo Pedro Pereira Samuel Ferreira Core Team Rui Gomes Rog\u00e9rio Peixoto Jo\u00e3o Reigota Felipe Avelar Nuno Oliveira Mark Mishaev Igor Markov Ori Bendet Erez Yalon Thank you all!","title":"Contribution"},{"location":"CONTRIBUTING/#contribution","text":"We would like to THANK YOU for considering contributing to KICS! KICS is a true community project. It's built as an open source from day one, and anyone can find his own way to contribute to the project. Within just minutes, you can start making a difference, by sharing your expertise with a community of thousands of security experts and software developers.","title":"Contribution"},{"location":"CONTRIBUTING/#contribution-options","text":"Good news! You don't have to contribute code. There are plenty of ways you can contribute to KICS project: Reporting new bugs or issues Help triaging issues Improving and translating the documentation Volunteering to maintain the project","title":"Contribution Options"},{"location":"CONTRIBUTING/#code-of-conduct","text":"By participating and contributing to the project, you agree to uphold our Code of Conduct .","title":"Code of Conduct"},{"location":"CONTRIBUTING/#get-started","text":"Follow the instructions below to setup local KICS development environment and push your changes. Fork the kics repo on GitHub. Clone your fork locally: git clone https://github.com/Checkmarx/kics.git Create a branch for local development. Use succinct but descriptive name (prefix with feature/issue#-descriptive-name> or hotfix/issue#-descriptive-name ): git checkout -b <name-of-your-issue> Make your changes locally. Validate your changes to reassure they meet project quality and contribution standards: golint . go mod vendor go test -mod=vendor -v ./... Commit your changes and push your branch to GitHub: git add . git commit git push --set-upstream origin <name-of-your-issue> Submit a pull request on GitHub website.","title":"Get Started!"},{"location":"CONTRIBUTING/#how-to-contribute","text":"Contributions are made to this repo via Issues and Pull Requests (PRs). A few general guidelines that cover both: Search for existing issues and pull requests before creating your own to avoid duplicates. PRs will only be accepted if associated with an issue (enhancement or bug) that has been submitted and reviewed/labeled as accepted . We will work hard to make sure issues that are raised are handled in a timely manner.","title":"How to Contribute"},{"location":"CONTRIBUTING/#issues","text":"Issues should be used to report problems with the solution / source code, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help by indicating to our maintainers that a particular problem is affecting more than just the reporter.","title":"Issues"},{"location":"CONTRIBUTING/#pull-requests","text":"Pull Requests (PRs) are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix/add the functionality in question or address code style issues, not both. Ensure all necessary details are provided and adhered to. Add unit or integration tests for fixed or changed functionality (if a test suite already exists) or specify steps taken to ensure changes were tested and functionality works as expected. Address a single concern in the least number of changed lines as possible. Include documentation in the repo or Provide additional comments in Markdown comments that should be pulled/reflected in GitHub Wiki for the given project. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), please open an Issue to discuss your proposal first.","title":"Pull Requests"},{"location":"CONTRIBUTING/#pull-request-guidelines","text":"Before you submit a pull request, please reassure that it meets these guidelines: All validations and tests passed locally. The pull request includes tests. The relevant docs are updated, whether you're pushing new functionality or updating a query.","title":"Pull Request Guidelines"},{"location":"CONTRIBUTING/#templates","text":"The following templates will be used when creating a new issue : Enhancement/Feature Request Template New (Approved) Feature Template Query Template Bug Report Template","title":"Templates"},{"location":"CONTRIBUTING/#resources","text":"How to Contribute to Open Source Using Pull Requests GitHub Help Join the chat on Gitter . Or contact KICS core team at kics@checkmarx.com And become one of our top contributors!","title":"Resources"},{"location":"CONTRIBUTING/#top-contributors","text":"Special thanks to Lior Kaplan from Kaplan Open Source Consulting for his assistance in creating KICS. The people listed below had made a huge contribution to KICS. Ruben Silva Rafaela Soares Jo\u00e3o Martins Joel Carvalho Pedro Mimoso Nuno Ara\u00fajo F\u00e1bio Gon\u00e7alves Mariana Carvalho Jorge Cruz Jo\u00e3o Oliveira Diogo Lemos Alex Roichman Adar Weidman Eli Trop Joel Sousa S\u00f3nia Ant\u00e3o Catarina Ara\u00fajo Pedro Pereira Samuel Ferreira","title":"Top Contributors"},{"location":"CONTRIBUTING/#core-team","text":"Rui Gomes Rog\u00e9rio Peixoto Jo\u00e3o Reigota Felipe Avelar Nuno Oliveira Mark Mishaev Igor Markov Ori Bendet Erez Yalon Thank you all!","title":"Core Team"},{"location":"about/","text":"About Checkmarx Checkmarx is the global leader in software security solutions for modern enterprise software development. Checkmarx delivers the industry\u2019s most comprehensive Software Security Platform that unifies with DevOps and provides static and interactive application security testing, software composition analysis and developer AppSec awareness and training programs to reduce and remediate risk from software vulnerabilities. Checkmarx is trusted by more than 40 percent of the Fortune 100 and half of the Fortune 50, including leading organizations such as SAP, Samsung and Salesforce.com. Contact KICS core team at kics@checkmarx.com or join the chat on Gitter . Infrastructure as Code Infrastructure as Code (IaC) is the creation, provisioning and configuration of software-defined compute (SDC), network and storage infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools. IaC automates the manual tasks usually associated with computing infrastructure configuration and implementation. By doing this, you can: Speed up configuration and implementation of new computing infrastructure Reduce the cost and resource needed to scale and manage large infrastructure Eliminate the inconsistencies that inevitably occur when multiple individuals manually configure new equipment or applications. The core concepts of Infrastructure as Code are: Defined in code Stored in a repository Declarative or Imperative Idempotence and Consistency Push or Pull Main Benefits of Infrastructure as Code: Fully automated deployment Consistent environments Repeatable process Reusable components (\"DRY\") Documented Architecture Infrastructure as Code Testing Infrastructure as Code testing examines configuration definitions and scripts used to instantiate infrastructure to ensure the resulting resources are secure. IaC security testing tools must be able to consume configuration files and scripts in relevant formats, apply tests to ensure conformance with common configuration hardening standards (i.e., Center for Internet Security Benchmarks and many others), identify security issues associated with specific operational environments, identify embedded secrets, and perform other tests supporting organization-specific standards and compliance requirements. Optionally, tools can automatically remediate errors (e.g., changing read/write permissions on storage resources). This capability specifically examines IaC testing in the context of the development process, however tools may also support examination of deployed production instances and responding to issues identified in those systems.","title":"About"},{"location":"about/#about-checkmarx","text":"Checkmarx is the global leader in software security solutions for modern enterprise software development. Checkmarx delivers the industry\u2019s most comprehensive Software Security Platform that unifies with DevOps and provides static and interactive application security testing, software composition analysis and developer AppSec awareness and training programs to reduce and remediate risk from software vulnerabilities. Checkmarx is trusted by more than 40 percent of the Fortune 100 and half of the Fortune 50, including leading organizations such as SAP, Samsung and Salesforce.com. Contact KICS core team at kics@checkmarx.com or join the chat on Gitter .","title":"About Checkmarx"},{"location":"about/#infrastructure-as-code","text":"Infrastructure as Code (IaC) is the creation, provisioning and configuration of software-defined compute (SDC), network and storage infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools. IaC automates the manual tasks usually associated with computing infrastructure configuration and implementation. By doing this, you can: Speed up configuration and implementation of new computing infrastructure Reduce the cost and resource needed to scale and manage large infrastructure Eliminate the inconsistencies that inevitably occur when multiple individuals manually configure new equipment or applications. The core concepts of Infrastructure as Code are: Defined in code Stored in a repository Declarative or Imperative Idempotence and Consistency Push or Pull Main Benefits of Infrastructure as Code: Fully automated deployment Consistent environments Repeatable process Reusable components (\"DRY\") Documented Architecture","title":"Infrastructure as Code"},{"location":"about/#infrastructure-as-code-testing","text":"Infrastructure as Code testing examines configuration definitions and scripts used to instantiate infrastructure to ensure the resulting resources are secure. IaC security testing tools must be able to consume configuration files and scripts in relevant formats, apply tests to ensure conformance with common configuration hardening standards (i.e., Center for Internet Security Benchmarks and many others), identify security issues associated with specific operational environments, identify embedded secrets, and perform other tests supporting organization-specific standards and compliance requirements. Optionally, tools can automatically remediate errors (e.g., changing read/write permissions on storage resources). This capability specifically examines IaC testing in the context of the development process, however tools may also support examination of deployed production instances and responding to issues identified in those systems.","title":"Infrastructure as Code Testing"},{"location":"architecture/","text":"Overview KICS is 100% open source is written in Golang using Open Policy Agent ( OPA ). Golang speed, simplicity and reliability made it the perfect choice for writing KICS, while Rego as a query language, was a native choice to implement security queries. So far have written 1000+ ready-to-use queries that cover a wide range of vulnerabilities checks for AWS, GCP, Azure and other cloud providers. High Level Architecture KICS has a pluggable architecture with extensible pipeline of parsing IaC languages, which allows an easy integration of new IaC languages and queries. At a high very level, KICS is composed of the following main components: a command line interface, parser, queries execution engine, IaC providers, security queries, and results writer. Command Line Interface => Provides CLI input to KICS. Parser => responsible for parsing input IaC files (terraform and others) IaC Providers => Converts IaC language into normalized JSON Queries Execution Engine => applies REGO queries against normalized JSON Security Queries => pre-built REGO queries for each security and misconfiguration Writer => Writes results into JSON format Execution Flow The sequence diagram below depicts interaction of the main KICS components:","title":"Architecture"},{"location":"architecture/#overview","text":"KICS is 100% open source is written in Golang using Open Policy Agent ( OPA ). Golang speed, simplicity and reliability made it the perfect choice for writing KICS, while Rego as a query language, was a native choice to implement security queries. So far have written 1000+ ready-to-use queries that cover a wide range of vulnerabilities checks for AWS, GCP, Azure and other cloud providers.","title":"Overview"},{"location":"architecture/#high-level-architecture","text":"KICS has a pluggable architecture with extensible pipeline of parsing IaC languages, which allows an easy integration of new IaC languages and queries. At a high very level, KICS is composed of the following main components: a command line interface, parser, queries execution engine, IaC providers, security queries, and results writer. Command Line Interface => Provides CLI input to KICS. Parser => responsible for parsing input IaC files (terraform and others) IaC Providers => Converts IaC language into normalized JSON Queries Execution Engine => applies REGO queries against normalized JSON Security Queries => pre-built REGO queries for each security and misconfiguration Writer => Writes results into JSON format","title":"High Level Architecture"},{"location":"architecture/#execution-flow","text":"The sequence diagram below depicts interaction of the main KICS components:","title":"Execution Flow"},{"location":"code-of-conduct/","text":"Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at kics@checkmarx.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Contributor Covenant Code of Conduct"},{"location":"code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code-of-conduct/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"code-of-conduct/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code-of-conduct/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"code-of-conduct/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at kics@checkmarx.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"code-of-conduct/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"code-of-conduct/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"code-of-conduct/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"code-of-conduct/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"code-of-conduct/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Attribution"},{"location":"configuration-file/","text":"Configuration File KICS allow you to provide all configurations either as command line arguments or as code. Here is a Configuration file example: { \"path\": \"assets/iac_samples\", \"verbose\": true, \"log-file\": true, \"type\": \"Dockerfile,Kubernetes\", \"queries-path\": \"assets/queries\", \"output-path\": \"results.json\" } The same example now in YAML format passing type as an array of strings: path: assets/iac_samples verbose: true log-file: true type: - Dockerfile - Kubernetes queries-path: \"assets/queries\" output-path: \"results.json\" \ud83d\udcdd flags that can receive multiple values can be either provided as a comma separated string or an array as in the example above Supported Formats KICS supports the following formats for the configuration files. JSON TOML YAML HCL Notice that format is about the content and not the file extension. KICS is able to infer the format without the need of file extension. Templates JSON Format { \"path\": \"path to file or directory to scan\", \"verbose\": true, \"log-file\": true, \"queries-path\": \"path to directory with queries (default ./assets/queries) (default './assets/queries')\", \"output-path\": \"file path to store result in json format\", \"exclude-paths\": \"exclude paths or files from scan\", \"no-progress\": false, \"type\": \"type of queries to use in the scan\", \"payload-path\": \"file path to store source internal representation in JSON format\", \"exclude-results\": \"exclude results by providing a list of similarity IDs of a result\" } YAML Format path: \"path to file or directory to scan\" verbose: true log-file: true queries-path: \"path to directory with queries (default ./assets/queries) (default './assets/queries')\" output-path: \"file path to store result in json format\" exclude-paths: \"exclude paths or files from scan\" no-progress: false type: \"type of queries to use in the scan\" payload-path: \"file path to store source internal representation in JSON format\" exclude-results: \"exclude results by providing a list of similarity IDs of a result\" TOML Format path = \"path to file or directory to scan\" verbose = true log-file = true queries-path = \"path to directory with queries (default ./assets/queries) (default './assets/queries')\" output-path = \"file path to store result in json format\" exclude-paths = \"exclude paths or files from scan\" no-progress = false type = \"type of queries to use in the scan\" payload-path = \"file path to store source internal representation in JSON format\" exclude-results = \"exclude results by providing a list of similarity IDs of a result\" HCL Format \"exclude-paths\" = \"exclude paths or files from scan\" \"log-file\" = true \"no-progress\" = false \"output-path\" = \"file path to store result in json format\" \"path\" = \"path to file or directory to scan\" \"payload-path\" = \"file path to store source internal representation in JSON format\" \"queries-path\" = \"path to directory with queries (default ./assets/queries) (default './assets/queries')\" \"type\" = \"type of queries to use in the scan\" \"verbose\" = true \"exclude-results\" = \"exclude results by providing a list of similarity IDs of a result\" How to Use You can enclose all your configurations in a file and use it in two different ways. Command Argument File Create a file with any name/any extension. For the sake of example, let's call it kics-config.json Add the necessary configurations as shown in the templates section in any of the supported formats. Pass the configuration file as argument: kics scan --config kics-config.json Configuration as Code Create a file named kics.config and place it in the root of your project repository. Add the necessary configurations as shown in the templates section in any of the supported formats. Invoke KICS without arguments (KICS will search for the specific file in the root) kics scan Note : CLI flags will have priority over the configuration file properties!","title":"Configuration"},{"location":"configuration-file/#configuration-file","text":"KICS allow you to provide all configurations either as command line arguments or as code. Here is a Configuration file example: { \"path\": \"assets/iac_samples\", \"verbose\": true, \"log-file\": true, \"type\": \"Dockerfile,Kubernetes\", \"queries-path\": \"assets/queries\", \"output-path\": \"results.json\" } The same example now in YAML format passing type as an array of strings: path: assets/iac_samples verbose: true log-file: true type: - Dockerfile - Kubernetes queries-path: \"assets/queries\" output-path: \"results.json\" \ud83d\udcdd flags that can receive multiple values can be either provided as a comma separated string or an array as in the example above","title":"Configuration File"},{"location":"configuration-file/#supported-formats","text":"KICS supports the following formats for the configuration files. JSON TOML YAML HCL Notice that format is about the content and not the file extension. KICS is able to infer the format without the need of file extension.","title":"Supported Formats"},{"location":"configuration-file/#templates","text":"","title":"Templates"},{"location":"configuration-file/#json-format","text":"{ \"path\": \"path to file or directory to scan\", \"verbose\": true, \"log-file\": true, \"queries-path\": \"path to directory with queries (default ./assets/queries) (default './assets/queries')\", \"output-path\": \"file path to store result in json format\", \"exclude-paths\": \"exclude paths or files from scan\", \"no-progress\": false, \"type\": \"type of queries to use in the scan\", \"payload-path\": \"file path to store source internal representation in JSON format\", \"exclude-results\": \"exclude results by providing a list of similarity IDs of a result\" }","title":"JSON Format"},{"location":"configuration-file/#yaml-format","text":"path: \"path to file or directory to scan\" verbose: true log-file: true queries-path: \"path to directory with queries (default ./assets/queries) (default './assets/queries')\" output-path: \"file path to store result in json format\" exclude-paths: \"exclude paths or files from scan\" no-progress: false type: \"type of queries to use in the scan\" payload-path: \"file path to store source internal representation in JSON format\" exclude-results: \"exclude results by providing a list of similarity IDs of a result\"","title":"YAML Format"},{"location":"configuration-file/#toml-format","text":"path = \"path to file or directory to scan\" verbose = true log-file = true queries-path = \"path to directory with queries (default ./assets/queries) (default './assets/queries')\" output-path = \"file path to store result in json format\" exclude-paths = \"exclude paths or files from scan\" no-progress = false type = \"type of queries to use in the scan\" payload-path = \"file path to store source internal representation in JSON format\" exclude-results = \"exclude results by providing a list of similarity IDs of a result\"","title":"TOML Format"},{"location":"configuration-file/#hcl-format","text":"\"exclude-paths\" = \"exclude paths or files from scan\" \"log-file\" = true \"no-progress\" = false \"output-path\" = \"file path to store result in json format\" \"path\" = \"path to file or directory to scan\" \"payload-path\" = \"file path to store source internal representation in JSON format\" \"queries-path\" = \"path to directory with queries (default ./assets/queries) (default './assets/queries')\" \"type\" = \"type of queries to use in the scan\" \"verbose\" = true \"exclude-results\" = \"exclude results by providing a list of similarity IDs of a result\"","title":"HCL Format"},{"location":"configuration-file/#how-to-use","text":"You can enclose all your configurations in a file and use it in two different ways.","title":"How to Use"},{"location":"configuration-file/#command-argument-file","text":"Create a file with any name/any extension. For the sake of example, let's call it kics-config.json Add the necessary configurations as shown in the templates section in any of the supported formats. Pass the configuration file as argument: kics scan --config kics-config.json","title":"Command Argument File"},{"location":"configuration-file/#configuration-as-code","text":"Create a file named kics.config and place it in the root of your project repository. Add the necessary configurations as shown in the templates section in any of the supported formats. Invoke KICS without arguments (KICS will search for the specific file in the root) kics scan Note : CLI flags will have priority over the configuration file properties!","title":"Configuration as Code"},{"location":"getting-started/","text":"Installation There are multiple ways to get KICS up and running: Docker KICS is available as a Docker image and can be used as follows: To scan a directory/file on your host you have to mount it as a volume to the container and specify the path on the container filesystem with the -p KICS parameter (see Scan Command Options section below) docker pull checkmarx/kics:latest docker run -v {\u200b\u200b\u200b\u200bpath_to_host_folder_to_scan}\u200b\u200b\u200b\u200b:/path checkmarx/kics:latest scan -p \"/path\" -o \"/path/results.json\" You can provide your own path to the queries directory with -q CLI option (see CLI Options section below), otherwise the default directory will be used The default ./assets/queries is built-in in the image. Binary KICS release process is pretty straightforward. When we're releasing a new version, we'll pack KICS executables for both Linux and Windows operating systems. Our security queries will be included in the ZIP files and tarballs, so that you can scan your IaC code with the out-of-the-box queries So all you need is: Go to KICS releases Download KICS binaries based on your OS Extract files Run kics executable with the cli options as described below (note that kics binary should be located in the same directory as queries directory) ./kics scan -p <path-of-your-project-to-scan> -o <output-results.json> Build from Sources Download and install Go from https://golang.org/dl/ Clone the repository: git clone https://github.com/Checkmarx/kics.git cd kics Kick a scan! go run ./cmd/console/main.go scan -p <path-of-your-project-to-scan> -o <output-results.json> KICS Commands KICS can interpret the following commands: generate-id Generates uuid for query help Help about any command scan Executes a scan analysis version Displays the current version Scan Command Options Executes a scan analysis Usage: kics scan [flags] kics scan [command] Available Commands: list-platforms List supported platforms Flags: --config string path to configuration file -e, --exclude-paths strings exclude paths from scan supports glob and can be provided multiple times or as a quoted comma separated string example: './shouldNotScan/*,somefile.txt' -x, --exclude-results strings exclude results by providing the similarity ID of a result can be provided multiple times or as a comma separated string example: 'fec62a97d569662093dbb9739360942f...,31263s5696620s93dbb973d9360942fc2a...' -h, --help help for scan -l, --log-file writes log messages to info.log --no-progress hides the progress bar -o, --output-path string file path to store result in json format -p, --path string path or directory path to scan -d, --payload-path string path to store internal representation JSON file -q, --queries-path string path to directory with queries (default \"./assets/queries\") -t, --type strings case insensitive list of platform types to scan (Ansible, CloudFormation, Dockerfile, Kubernetes, Terraform) -v, --verbose increase verbosity The other commands have no further options. Next Steps Understand how to configure KICS so you can have a better KICS experience. Explore the queries internals for better understanding how KICS works. Explore the output results format and quickly fix the issues detected. Contribute if you want to go the extra mile.","title":"Installation"},{"location":"getting-started/#installation","text":"There are multiple ways to get KICS up and running:","title":"Installation"},{"location":"getting-started/#docker","text":"KICS is available as a Docker image and can be used as follows: To scan a directory/file on your host you have to mount it as a volume to the container and specify the path on the container filesystem with the -p KICS parameter (see Scan Command Options section below) docker pull checkmarx/kics:latest docker run -v {\u200b\u200b\u200b\u200bpath_to_host_folder_to_scan}\u200b\u200b\u200b\u200b:/path checkmarx/kics:latest scan -p \"/path\" -o \"/path/results.json\" You can provide your own path to the queries directory with -q CLI option (see CLI Options section below), otherwise the default directory will be used The default ./assets/queries is built-in in the image.","title":"Docker"},{"location":"getting-started/#binary","text":"KICS release process is pretty straightforward. When we're releasing a new version, we'll pack KICS executables for both Linux and Windows operating systems. Our security queries will be included in the ZIP files and tarballs, so that you can scan your IaC code with the out-of-the-box queries So all you need is: Go to KICS releases Download KICS binaries based on your OS Extract files Run kics executable with the cli options as described below (note that kics binary should be located in the same directory as queries directory) ./kics scan -p <path-of-your-project-to-scan> -o <output-results.json>","title":"Binary"},{"location":"getting-started/#build-from-sources","text":"Download and install Go from https://golang.org/dl/ Clone the repository: git clone https://github.com/Checkmarx/kics.git cd kics Kick a scan! go run ./cmd/console/main.go scan -p <path-of-your-project-to-scan> -o <output-results.json>","title":"Build from Sources"},{"location":"getting-started/#kics-commands","text":"KICS can interpret the following commands: generate-id Generates uuid for query help Help about any command scan Executes a scan analysis version Displays the current version","title":"KICS Commands"},{"location":"getting-started/#scan-command-options","text":"Executes a scan analysis Usage: kics scan [flags] kics scan [command] Available Commands: list-platforms List supported platforms Flags: --config string path to configuration file -e, --exclude-paths strings exclude paths from scan supports glob and can be provided multiple times or as a quoted comma separated string example: './shouldNotScan/*,somefile.txt' -x, --exclude-results strings exclude results by providing the similarity ID of a result can be provided multiple times or as a comma separated string example: 'fec62a97d569662093dbb9739360942f...,31263s5696620s93dbb973d9360942fc2a...' -h, --help help for scan -l, --log-file writes log messages to info.log --no-progress hides the progress bar -o, --output-path string file path to store result in json format -p, --path string path or directory path to scan -d, --payload-path string path to store internal representation JSON file -q, --queries-path string path to directory with queries (default \"./assets/queries\") -t, --type strings case insensitive list of platform types to scan (Ansible, CloudFormation, Dockerfile, Kubernetes, Terraform) -v, --verbose increase verbosity The other commands have no further options.","title":"Scan Command Options"},{"location":"getting-started/#next-steps","text":"Understand how to configure KICS so you can have a better KICS experience. Explore the queries internals for better understanding how KICS works. Explore the output results format and quickly fix the issues detected. Contribute if you want to go the extra mile.","title":"Next Steps"},{"location":"integrations/","text":"Integrations Overview You can integrate KICS with your favorite CI/CD pipelines. We provide plugins for some CI/CD tools. For some others we provide a tutorial on how the integration can be done. Integrate KICS with Github Actions Integrate KICS with GitLab CI Integrate KICS with Azure Pipelines Integrate KICS with Bitbucket Pipelines More soon...","title":"Overview"},{"location":"integrations/#integrations-overview","text":"You can integrate KICS with your favorite CI/CD pipelines. We provide plugins for some CI/CD tools. For some others we provide a tutorial on how the integration can be done. Integrate KICS with Github Actions Integrate KICS with GitLab CI Integrate KICS with Azure Pipelines Integrate KICS with Bitbucket Pipelines More soon...","title":"Integrations Overview"},{"location":"integrations_azurepipelines/","text":"Integrate KICS with Azure Pipelines You can integrate KICS into your Azure Pipelines CI/CD. This provides you the ability to run KICS scans in your GitLab repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC). Tutorial The following tutorial is a possible way of using KICS in Azure Pipelines CI. You can be creative and come up with different solutions that fit your pipelines. In this case we instruct the job to download and use the latest Linux version of KICS. 1- Edit or add a new azure-pipelines.yml file in the root of your repository 2- Declare a new stage stages: - stage: kics displayName: kics 3- Declare the steps - in this case it is a script where we follow the steps: 3.1- Get the OS name: OS=$(uname -s) 3.2- Declare version and KICS binaries to download get_latest_kics_release() { curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/' } LATEST_TAG=$(get_latest_kics_release) LATEST_VERSION=${LATEST_TAG#v} PACKAGE_NAME=kics_${LATEST_VERSION}_${OS}_x64.tar.gz TARGET_DIR=/home/vsts/kics 3.3- Download the binary mkdir -p ${TARGET_DIR} wget -q -c https://github.com/Checkmarx/kics/releases/download/${LATEST_TAG}/${PACKAGE_NAME} -O - | tar -xz -C ${TARGET_DIR} 3.4- Start the scan ${TARGET_DIR}/kics --no-progress -q ${TARGET_DIR}/assets/queries -p ${PWD} -o ${PWD}/kics-results.json 3.5- Consume the results TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` echo \"TOTAL SEVERITY COUNTER $TOTAL_SEVERITY_COUNTER\" 3.6- Optionally, define a breaking point for the CI if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ]; then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY COUNTERS\" && exit 1; fi Here is the full content of the job trigger: - master pool: vmImage: 'ubuntu-latest' stages: - stage: kics displayName: kics jobs: - job: runKics displayName: runKics steps: - script: | get_latest_kics_release() { curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/' } OS=$(uname -s) LATEST_TAG=$(get_latest_kics_release) LATEST_VERSION=${LATEST_TAG#v} PACKAGE_NAME=kics_${LATEST_VERSION}_${OS}_x64.tar.gz TARGET_DIR=/home/vsts/kics mkdir -p ${TARGET_DIR} wget -q -c https://github.com/Checkmarx/kics/releases/download/${LATEST_TAG}/${PACKAGE_NAME} -O - | tar -xz -C ${TARGET_DIR} echo '--- START SCANNING ---' ${TARGET_DIR}/kics --no-progress -q ${TARGET_DIR}/assets/queries -p ${PWD} -o ${PWD}/kics-results.json TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` echo \"TOTAL SEVERITY COUNTER $TOTAL_SEVERITY_COUNTER\" if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ]; then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY COUNTERS\" && exit 1; fi Example Results When your pipeline executes, it will run this job. If KICS finds any issues, it will fail the build. Pipeline Failure Pipeline Success","title":"Azure DevOps"},{"location":"integrations_azurepipelines/#integrate-kics-with-azure-pipelines","text":"You can integrate KICS into your Azure Pipelines CI/CD. This provides you the ability to run KICS scans in your GitLab repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC).","title":"Integrate KICS with Azure Pipelines"},{"location":"integrations_azurepipelines/#tutorial","text":"The following tutorial is a possible way of using KICS in Azure Pipelines CI. You can be creative and come up with different solutions that fit your pipelines. In this case we instruct the job to download and use the latest Linux version of KICS. 1- Edit or add a new azure-pipelines.yml file in the root of your repository 2- Declare a new stage stages: - stage: kics displayName: kics 3- Declare the steps - in this case it is a script where we follow the steps: 3.1- Get the OS name: OS=$(uname -s) 3.2- Declare version and KICS binaries to download get_latest_kics_release() { curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/' } LATEST_TAG=$(get_latest_kics_release) LATEST_VERSION=${LATEST_TAG#v} PACKAGE_NAME=kics_${LATEST_VERSION}_${OS}_x64.tar.gz TARGET_DIR=/home/vsts/kics 3.3- Download the binary mkdir -p ${TARGET_DIR} wget -q -c https://github.com/Checkmarx/kics/releases/download/${LATEST_TAG}/${PACKAGE_NAME} -O - | tar -xz -C ${TARGET_DIR} 3.4- Start the scan ${TARGET_DIR}/kics --no-progress -q ${TARGET_DIR}/assets/queries -p ${PWD} -o ${PWD}/kics-results.json 3.5- Consume the results TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` echo \"TOTAL SEVERITY COUNTER $TOTAL_SEVERITY_COUNTER\" 3.6- Optionally, define a breaking point for the CI if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ]; then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY COUNTERS\" && exit 1; fi Here is the full content of the job trigger: - master pool: vmImage: 'ubuntu-latest' stages: - stage: kics displayName: kics jobs: - job: runKics displayName: runKics steps: - script: | get_latest_kics_release() { curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/' } OS=$(uname -s) LATEST_TAG=$(get_latest_kics_release) LATEST_VERSION=${LATEST_TAG#v} PACKAGE_NAME=kics_${LATEST_VERSION}_${OS}_x64.tar.gz TARGET_DIR=/home/vsts/kics mkdir -p ${TARGET_DIR} wget -q -c https://github.com/Checkmarx/kics/releases/download/${LATEST_TAG}/${PACKAGE_NAME} -O - | tar -xz -C ${TARGET_DIR} echo '--- START SCANNING ---' ${TARGET_DIR}/kics --no-progress -q ${TARGET_DIR}/assets/queries -p ${PWD} -o ${PWD}/kics-results.json TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` echo \"TOTAL SEVERITY COUNTER $TOTAL_SEVERITY_COUNTER\" if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ]; then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY COUNTERS\" && exit 1; fi","title":"Tutorial"},{"location":"integrations_azurepipelines/#example-results","text":"When your pipeline executes, it will run this job. If KICS finds any issues, it will fail the build.","title":"Example Results"},{"location":"integrations_azurepipelines/#pipeline-failure","text":"","title":"Pipeline Failure"},{"location":"integrations_azurepipelines/#pipeline-success","text":"","title":"Pipeline Success"},{"location":"integrations_bitbucketpipelines/","text":"Integrate KICS with Bitbucket Pipelines You can integrate KICS into Bitbucket Pipelines CI/CD. This provides you the ability to run KICS scans in your Bitbucket repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC). Example configuration image: atlassian/default-image:2 pipelines: default: - step: name: 'Cx KICS' script: - LATEST_KICS_TAG=$(curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/') - LATEST_KICS_VERSION=${LATEST_KICS_TAG#v} - wget -q -c \"https://github.com/Checkmarx/kics/releases/download/${LATEST_KICS_TAG}/kics_${LATEST_KICS_VERSION}_linux_x64.tar.gz\" -O - | tar -xz --directory /usr/bin &>/dev/null - kics -q /usr/bin/assets/queries -p ${PWD} -o ${PWD}/kics-results.json - TOTAL_SEVERITY_COUNTER=`grep '\"totalCounter\"':' ' ${PWD}/kics-results.json | awk {'print $2'}` - export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - echo \"TOTAL SEVERITY COUNTER $TOTAL_SEVERITY_COUNTER\" - if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ];then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY COUNTERS\" && exit 1;fi artifacts: - kics-results.json","title":"Bitbucket Pipelines"},{"location":"integrations_bitbucketpipelines/#integrate-kics-with-bitbucket-pipelines","text":"You can integrate KICS into Bitbucket Pipelines CI/CD. This provides you the ability to run KICS scans in your Bitbucket repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC).","title":"Integrate KICS with Bitbucket Pipelines"},{"location":"integrations_bitbucketpipelines/#example-configuration","text":"image: atlassian/default-image:2 pipelines: default: - step: name: 'Cx KICS' script: - LATEST_KICS_TAG=$(curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/') - LATEST_KICS_VERSION=${LATEST_KICS_TAG#v} - wget -q -c \"https://github.com/Checkmarx/kics/releases/download/${LATEST_KICS_TAG}/kics_${LATEST_KICS_VERSION}_linux_x64.tar.gz\" -O - | tar -xz --directory /usr/bin &>/dev/null - kics -q /usr/bin/assets/queries -p ${PWD} -o ${PWD}/kics-results.json - TOTAL_SEVERITY_COUNTER=`grep '\"totalCounter\"':' ' ${PWD}/kics-results.json | awk {'print $2'}` - export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' ${PWD}/kics-results.json | awk {'print $2'} | sed 's/.$//'` - echo \"TOTAL SEVERITY COUNTER $TOTAL_SEVERITY_COUNTER\" - if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ];then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY COUNTERS\" && exit 1;fi artifacts: - kics-results.json","title":"Example configuration"},{"location":"integrations_ghactions/","text":"Integration with Github Actions You can integrate KICS into your Github Actions CI/CD pipelines with a specific KICS Github Action. This provides you the ability to run KICS scans in your Github repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC). Tutorial Edit the workflow file you want to integrate KICS in Either search Github Marketplace or use the template below: - name: KICS Github Action uses: Checkmarx/kics-github-action@v1.0 with: # path to file or directory to scan path: # file path to store result in json format output_path: # optional # file path to store source internal representation in JSON format payload_path: # optional # path to directory with queries (default \"./assets/queries\") queries: # optional # verbose scan verbose: # optional Example #... steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 - name: run kics Scan uses: checkmarx/kics-github-action@v1.0 with: path: 'terraform' output_path: 'results.json' - name: display kics results run: | cat results.json Here you can see it in action: Resources KICS GitHub Action in Github Marketplace . KICS Github Action Project Repository . Github Actions in Github Documentation","title":"Github Actions"},{"location":"integrations_ghactions/#integration-with-github-actions","text":"You can integrate KICS into your Github Actions CI/CD pipelines with a specific KICS Github Action. This provides you the ability to run KICS scans in your Github repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC).","title":"Integration with Github Actions"},{"location":"integrations_ghactions/#tutorial","text":"Edit the workflow file you want to integrate KICS in Either search Github Marketplace or use the template below: - name: KICS Github Action uses: Checkmarx/kics-github-action@v1.0 with: # path to file or directory to scan path: # file path to store result in json format output_path: # optional # file path to store source internal representation in JSON format payload_path: # optional # path to directory with queries (default \"./assets/queries\") queries: # optional # verbose scan verbose: # optional","title":"Tutorial"},{"location":"integrations_ghactions/#example","text":"#... steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 - name: run kics Scan uses: checkmarx/kics-github-action@v1.0 with: path: 'terraform' output_path: 'results.json' - name: display kics results run: | cat results.json Here you can see it in action:","title":"Example"},{"location":"integrations_ghactions/#resources","text":"KICS GitHub Action in Github Marketplace . KICS Github Action Project Repository . Github Actions in Github Documentation","title":"Resources"},{"location":"integrations_gitlabci/","text":"Integrate KICS with GitLab CI You can integrate KICS into your GitLab CI/CD pipelines. This provides you the ability to run KICS scans in your GitLab repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC). Tutorial The following tutorial is a possible way of using KICS in GitLab CI. You can be creative and come up with different solutions that fit your pipelines. In this case we instruct the job to download and use the latest Linux version of KICS. 1- Edit or add a new job in the .gitlab-ci.yml file in your repository. 2- In the beginning of the job, instruct it to get the latest version of KICS, for example in before_script : before_script: - apk add --no-cache libc6-compat curl - TAG=`curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/'` - VERSION=`echo $TAG | sed -r 's/^.{1}//'` - wget -q -c \"https://github.com/Checkmarx/kics/releases/download/${TAG}/kics_${VERSION}_linux_x64.tar.gz\" -O - | tar -xz --directory /usr/bin &>/dev/null 3- Define the necessary stages. For instance, scan with KICS and consume the results stages: - kics - kics-result 4- Declare the KICS scan kics-scan: stage: kics script: - kics scan -q /usr/bin/assets/queries -p ${PWD} -o ${PWD}/kics-results.json artifacts: name: kics-results.json paths: - kics-results.json 5- Declare the consumption of results kics-results: stage: kics-result before_script: - export TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` - export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` script: - | echo \"TOTAL SEVERITY COUNTER: $TOTAL_SEVERITY_COUNTER SEVERITY COUNTER HIGH: $SEVERITY_COUNTER_HIGH SEVERITY COUNTER MEDIUM: $SEVERITY_COUNTER_MEDIUM SEVERITY COUNTER LOW: $SEVERITY_COUNTER_LOW SEVERITY COUNTER INFO: $SEVERITY_COUNTER_INFO\" - if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ];then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY ISSUES\" && exit 1;fi Notice the last line, where it is defined a failing CI condition in case there is at least 1 High Severity result. Here is the full example: image: alpine before_script: - apk add --no-cache libc6-compat curl - DATETIME=\"`date '+%H:%M'`\" - TAG=`curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/'` - echo \"${DATETIME} - INF latest tag is $TAG\" - VERSION=`echo $TAG | sed -r 's/^.{1}//'` - echo \"${DATETIME} - INF version is $VERSION\" - echo \"${DATETIME} - INF downloading latest kics binaries kics_${VERSION}_linux_x64.tar.gz\" - wget -q -c \"https://github.com/Checkmarx/kics/releases/download/${TAG}/kics_${VERSION}_linux_x64.tar.gz\" -O - | tar -xz --directory /usr/bin &>/dev/null stages: - kics - kics-result kics-scan: stage: kics script: - kics scan -q /usr/bin/assets/queries -p ${PWD} -o ${PWD}/kics-results.json artifacts: name: kics-results.json paths: - kics-results.json kics-results: stage: kics-result before_script: - export TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` - export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` script: - | echo \"TOTAL SEVERITY COUNTER: $TOTAL_SEVERITY_COUNTER SEVERITY COUNTER HIGH: $SEVERITY_COUNTER_HIGH SEVERITY COUNTER MEDIUM: $SEVERITY_COUNTER_MEDIUM SEVERITY COUNTER LOW: $SEVERITY_COUNTER_LOW SEVERITY COUNTER INFO: $SEVERITY_COUNTER_INFO\" - if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ];then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY ISSUES\" && exit 1;fi Example Results When your pipeline executes, it will run this job. If KICS finds any issues, it will fail the build. Pipeline Failure Pipeline Success Download Artifact","title":"Gitlab CI"},{"location":"integrations_gitlabci/#integrate-kics-with-gitlab-ci","text":"You can integrate KICS into your GitLab CI/CD pipelines. This provides you the ability to run KICS scans in your GitLab repositories and streamline vulnerabilities and misconfiguration checks to your infrastructure as code (IaC).","title":"Integrate KICS with GitLab CI"},{"location":"integrations_gitlabci/#tutorial","text":"The following tutorial is a possible way of using KICS in GitLab CI. You can be creative and come up with different solutions that fit your pipelines. In this case we instruct the job to download and use the latest Linux version of KICS. 1- Edit or add a new job in the .gitlab-ci.yml file in your repository. 2- In the beginning of the job, instruct it to get the latest version of KICS, for example in before_script : before_script: - apk add --no-cache libc6-compat curl - TAG=`curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/'` - VERSION=`echo $TAG | sed -r 's/^.{1}//'` - wget -q -c \"https://github.com/Checkmarx/kics/releases/download/${TAG}/kics_${VERSION}_linux_x64.tar.gz\" -O - | tar -xz --directory /usr/bin &>/dev/null 3- Define the necessary stages. For instance, scan with KICS and consume the results stages: - kics - kics-result 4- Declare the KICS scan kics-scan: stage: kics script: - kics scan -q /usr/bin/assets/queries -p ${PWD} -o ${PWD}/kics-results.json artifacts: name: kics-results.json paths: - kics-results.json 5- Declare the consumption of results kics-results: stage: kics-result before_script: - export TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` - export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` script: - | echo \"TOTAL SEVERITY COUNTER: $TOTAL_SEVERITY_COUNTER SEVERITY COUNTER HIGH: $SEVERITY_COUNTER_HIGH SEVERITY COUNTER MEDIUM: $SEVERITY_COUNTER_MEDIUM SEVERITY COUNTER LOW: $SEVERITY_COUNTER_LOW SEVERITY COUNTER INFO: $SEVERITY_COUNTER_INFO\" - if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ];then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY ISSUES\" && exit 1;fi Notice the last line, where it is defined a failing CI condition in case there is at least 1 High Severity result. Here is the full example: image: alpine before_script: - apk add --no-cache libc6-compat curl - DATETIME=\"`date '+%H:%M'`\" - TAG=`curl --silent \"https://api.github.com/repos/Checkmarx/kics/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/'` - echo \"${DATETIME} - INF latest tag is $TAG\" - VERSION=`echo $TAG | sed -r 's/^.{1}//'` - echo \"${DATETIME} - INF version is $VERSION\" - echo \"${DATETIME} - INF downloading latest kics binaries kics_${VERSION}_linux_x64.tar.gz\" - wget -q -c \"https://github.com/Checkmarx/kics/releases/download/${TAG}/kics_${VERSION}_linux_x64.tar.gz\" -O - | tar -xz --directory /usr/bin &>/dev/null stages: - kics - kics-result kics-scan: stage: kics script: - kics scan -q /usr/bin/assets/queries -p ${PWD} -o ${PWD}/kics-results.json artifacts: name: kics-results.json paths: - kics-results.json kics-results: stage: kics-result before_script: - export TOTAL_SEVERITY_COUNTER=`grep '\"total_counter\"':' ' kics-results.json | awk {'print $2'}` - export SEVERITY_COUNTER_HIGH=`grep '\"HIGH\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_MEDIUM=`grep '\"INFO\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_LOW=`grep '\"LOW\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` - export SEVERITY_COUNTER_INFO=`grep '\"MEDIUM\"':' ' kics-results.json | awk {'print $2'} | sed 's/.$//'` script: - | echo \"TOTAL SEVERITY COUNTER: $TOTAL_SEVERITY_COUNTER SEVERITY COUNTER HIGH: $SEVERITY_COUNTER_HIGH SEVERITY COUNTER MEDIUM: $SEVERITY_COUNTER_MEDIUM SEVERITY COUNTER LOW: $SEVERITY_COUNTER_LOW SEVERITY COUNTER INFO: $SEVERITY_COUNTER_INFO\" - if [ \"$SEVERITY_COUNTER_HIGH\" -ge \"1\" ];then echo \"Please fix all $SEVERITY_COUNTER_HIGH HIGH SEVERITY ISSUES\" && exit 1;fi","title":"Tutorial"},{"location":"integrations_gitlabci/#example-results","text":"When your pipeline executes, it will run this job. If KICS finds any issues, it will fail the build.","title":"Example Results"},{"location":"integrations_gitlabci/#pipeline-failure","text":"","title":"Pipeline Failure"},{"location":"integrations_gitlabci/#pipeline-success","text":"","title":"Pipeline Success"},{"location":"integrations_gitlabci/#download-artifact","text":"","title":"Download Artifact"},{"location":"queries/","text":"Queries KICS queries are written in OPA (Rego). CxPolicy [ result ] { resource := input.document[i].resource.aws_s3_bucket[name] role = \"public-read\" resource.acl == role result := { \"documentId\": input.document[i].id, \"searchKey\": sprintf(\"aws_s3_bucket[%s].acl\", [name]), \"issueType\": \"IncorrectValue\", \"keyExpectedValue\": sprintf(\"aws_s3_bucket[%s].acl is private\", [name]), \"keyActualValue\": sprintf(\"aws_s3_bucket[%s].acl is %s\", [name, role]) } } Anatomy The anatomy of a query is straightforward. It builds up a policy and defines the result. The policy builds the pattern that breaks the security of the infrastructure code and which the query is looking for. The result defines the specific data used to present the vulnerability in the infrastructure code. Metadata Each query has a metadata.json companion file with all the relevant information about the vulnerability , including the severity, category and its description. For example, the JSON code above is the metadata corresponding to the query in the beginning of this document. { \"id\": \"5738faf3-3fe6-4614-a93d-f0003242d4f9\", \"queryName\": \"All Users Group Gets Read Access\", \"severity\": \"HIGH\", \"category\": \"Identity and Access Management\", \"descriptionText\": \"It's not recommended to allow read access for all user groups.\", \"descriptionUrl\": \"https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#acl\", \"platform\": \"Terraform\" } Organization Filesystem-wise, KICS queries are organized per IaC technology or tool (e.g., terraform, k8s, dockerfile, etc.) and grouped under provider (e.g., aws, gcp, azure, etc.) when applicable. Per each query created, it is mandatory the creation of test cases with, at least, one negative and positive case and a JSON file with data about the expected results, as shown below: [ { \"queryName\": \"All Users Group Gets Read Access\", \"severity\": \"HIGH\", \"line\": 3 } ] Summarizing, the following is the expected file tree for a query: - <technology> |- <provider> | |- <queryfolder> | | |- test | | | |- positive<.ext> | | | |- negative<.ext> | | | |- positive_expected_result.json | | |- metadata.json | | |- query.rego Also, a query can contains multiples positive and negative files, but all cases files names must start with negative or positive and each positive file must be referencered on positive_expected_result.json , as shown below: [ { \"queryName\": \"ELB Sensitive Port Is Exposed To Entire Network\", \"severity\": \"HIGH\", \"line\": 37, \"fileName\": \"positive1.yaml\" }, { \"queryName\": \"ELB Sensitive Port Is Exposed To Entire Network\", \"severity\": \"HIGH\", \"line\": 22, \"fileName\": \"positive2.yaml\" } ] And the file tree should be as follows: - <technology> |- <provider> | |- <queryfolder> | | |- test | | | |- positive1<.ext> | | | |- positive2<.ext> | | | |- negative1<.ext> | | | |- negative2<.ext> | | | |- positive_expected_result.json | | |- metadata.json | | |- query.rego Create a new Query The queries are written in Rego and our internal parser transforms every IaC file that supports into a universal JSON format. This way anyone can start working on a query by picking up a small sample of the vulnerability that the query should target, and convert this sample, that can be a .tf or .yaml file, to our JSON structure JSON. To convert the sample you can run the following command: go run ./cmd/console/main.go -p \"pathToTestData\" -d \"pathToGenerateJson\" So for example, if we wanted to transform a .tf file in ./code/test we could type: go run ./cmd/console/main.go -p \"./src/test\" -d \"src/test/input.json\" After having the .json that will be our Rego input, we can begin to write queries. To test and debug there are two ways: Using Rego playground Install Open Policy Agent extension in VS Code and create a simple folder with a .rego file for the query and a input.json for the sample to test against Testing For a query to be considered complete, it must be compliant with at least one positive and one negative test case. To run the unit tests you can run this command: go test -mod=vendor -v -cover ./... -count=1 Check if the new test was added correctly and if all tests are passing locally. If succeeds, a Pull Request can now be created. Guidelines Filling metadata.json: id should be filled with a UUID. You can use the built-in command to generate this: go run ./cmd/console/main.go generate-id queryName describes the name of the vulnerability severity can be filled with HIGH , MEDIUM , LOW or INFO category pick one of the following: Identity and Access Management Network Security Monitoring Encryption and Key Management Logging Operational Cloud Assets Management Vulnerability and Threat Management Backup and Disaster Recovery Domain Name System (DNS) Management Network Ports Security descriptionText should explain with detail the vulnerability and if possible provide a way to remediate descriptionUrl points to the official documentation about the resource being targeted platform refers to querys target platform","title":"Queries"},{"location":"queries/#queries","text":"KICS queries are written in OPA (Rego). CxPolicy [ result ] { resource := input.document[i].resource.aws_s3_bucket[name] role = \"public-read\" resource.acl == role result := { \"documentId\": input.document[i].id, \"searchKey\": sprintf(\"aws_s3_bucket[%s].acl\", [name]), \"issueType\": \"IncorrectValue\", \"keyExpectedValue\": sprintf(\"aws_s3_bucket[%s].acl is private\", [name]), \"keyActualValue\": sprintf(\"aws_s3_bucket[%s].acl is %s\", [name, role]) } }","title":"Queries"},{"location":"queries/#anatomy","text":"The anatomy of a query is straightforward. It builds up a policy and defines the result. The policy builds the pattern that breaks the security of the infrastructure code and which the query is looking for. The result defines the specific data used to present the vulnerability in the infrastructure code.","title":"Anatomy"},{"location":"queries/#metadata","text":"Each query has a metadata.json companion file with all the relevant information about the vulnerability , including the severity, category and its description. For example, the JSON code above is the metadata corresponding to the query in the beginning of this document. { \"id\": \"5738faf3-3fe6-4614-a93d-f0003242d4f9\", \"queryName\": \"All Users Group Gets Read Access\", \"severity\": \"HIGH\", \"category\": \"Identity and Access Management\", \"descriptionText\": \"It's not recommended to allow read access for all user groups.\", \"descriptionUrl\": \"https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#acl\", \"platform\": \"Terraform\" }","title":"Metadata"},{"location":"queries/#organization","text":"Filesystem-wise, KICS queries are organized per IaC technology or tool (e.g., terraform, k8s, dockerfile, etc.) and grouped under provider (e.g., aws, gcp, azure, etc.) when applicable. Per each query created, it is mandatory the creation of test cases with, at least, one negative and positive case and a JSON file with data about the expected results, as shown below: [ { \"queryName\": \"All Users Group Gets Read Access\", \"severity\": \"HIGH\", \"line\": 3 } ] Summarizing, the following is the expected file tree for a query: - <technology> |- <provider> | |- <queryfolder> | | |- test | | | |- positive<.ext> | | | |- negative<.ext> | | | |- positive_expected_result.json | | |- metadata.json | | |- query.rego Also, a query can contains multiples positive and negative files, but all cases files names must start with negative or positive and each positive file must be referencered on positive_expected_result.json , as shown below: [ { \"queryName\": \"ELB Sensitive Port Is Exposed To Entire Network\", \"severity\": \"HIGH\", \"line\": 37, \"fileName\": \"positive1.yaml\" }, { \"queryName\": \"ELB Sensitive Port Is Exposed To Entire Network\", \"severity\": \"HIGH\", \"line\": 22, \"fileName\": \"positive2.yaml\" } ] And the file tree should be as follows: - <technology> |- <provider> | |- <queryfolder> | | |- test | | | |- positive1<.ext> | | | |- positive2<.ext> | | | |- negative1<.ext> | | | |- negative2<.ext> | | | |- positive_expected_result.json | | |- metadata.json | | |- query.rego","title":"Organization"},{"location":"queries/#create-a-new-query","text":"The queries are written in Rego and our internal parser transforms every IaC file that supports into a universal JSON format. This way anyone can start working on a query by picking up a small sample of the vulnerability that the query should target, and convert this sample, that can be a .tf or .yaml file, to our JSON structure JSON. To convert the sample you can run the following command: go run ./cmd/console/main.go -p \"pathToTestData\" -d \"pathToGenerateJson\" So for example, if we wanted to transform a .tf file in ./code/test we could type: go run ./cmd/console/main.go -p \"./src/test\" -d \"src/test/input.json\" After having the .json that will be our Rego input, we can begin to write queries. To test and debug there are two ways: Using Rego playground Install Open Policy Agent extension in VS Code and create a simple folder with a .rego file for the query and a input.json for the sample to test against","title":"Create a new Query"},{"location":"queries/#testing","text":"For a query to be considered complete, it must be compliant with at least one positive and one negative test case. To run the unit tests you can run this command: go test -mod=vendor -v -cover ./... -count=1 Check if the new test was added correctly and if all tests are passing locally. If succeeds, a Pull Request can now be created.","title":"Testing"},{"location":"queries/#guidelines","text":"Filling metadata.json: id should be filled with a UUID. You can use the built-in command to generate this: go run ./cmd/console/main.go generate-id queryName describes the name of the vulnerability severity can be filled with HIGH , MEDIUM , LOW or INFO category pick one of the following: Identity and Access Management Network Security Monitoring Encryption and Key Management Logging Operational Cloud Assets Management Vulnerability and Threat Management Backup and Disaster Recovery Domain Name System (DNS) Management Network Ports Security descriptionText should explain with detail the vulnerability and if possible provide a way to remediate descriptionUrl points to the official documentation about the resource being targeted platform refers to querys target platform","title":"Guidelines"},{"location":"releases/","text":"Releases For our release versions we follow the SemVer specification, meaning that we structure our versions into a MAJOR.MINOR.PATCH semantic. Our current release process is structured in the following way: PATCH versions for minor backwards compatible bug fixes and new small features. This should have a bi-weekly cadence. MINOR versions will include functionality that is backwards compatible. This should have a monthly cadence. MAJOR versions for major functionality that it's added or changes that are not backwards compatible. Every release is packed with: Source code .zip/tarballs Binaries for Windows and Linux Docker image uploaded to DockerHub If waiting for a new release it's not enough, we also provide nightly builds that include the latest changes. You can find our releases here .","title":"Releases"},{"location":"releases/#releases","text":"For our release versions we follow the SemVer specification, meaning that we structure our versions into a MAJOR.MINOR.PATCH semantic. Our current release process is structured in the following way: PATCH versions for minor backwards compatible bug fixes and new small features. This should have a bi-weekly cadence. MINOR versions will include functionality that is backwards compatible. This should have a monthly cadence. MAJOR versions for major functionality that it's added or changes that are not backwards compatible. Every release is packed with: Source code .zip/tarballs Binaries for Windows and Linux Docker image uploaded to DockerHub If waiting for a new release it's not enough, we also provide nightly builds that include the latest changes. You can find our releases here .","title":"Releases"},{"location":"results/","text":"Results KICS results are output in clear and simple JSON format. Example: { \"files_scanned\": 2, \"files_parsed\": 2, \"files_failed_to_scan\": 0, \"queries_total\": 253, \"queries_failed_to_execute\": 0, \"queries_failed_to_compute_similarity_id\": 0, \"queries\": [ { \"query_name\": \"Container Allow Privilege Escalation Is True\", \"query_id\": \"c878abb4-cca5-4724-92b9-289be68bd47c\", \"severity\": \"MEDIUM\", \"platform\": \"Terraform\", \"files\": [ { \"file_name\": \"assets/queries/terraform/kubernetes_pod/container_allow_privilege_escalation_is_true/test/positive.tf\", \"similarity_id\": \"063ed2389809f5f01ff420b63634700a9545c5e5130a6506568f925cdb0f8e13\", \"line\": 11, \"issue_type\": \"IncorrectValue\", \"search_key\": \"kubernetes_pod[test3].spec.container.allow_privilege_escalation\", \"search_value\": \"\", \"expected_value\": \"Attribute 'allow_privilege_escalation' is undefined or false\", \"actual_value\": \"Attribute 'allow_privilege_escalation' is true\", \"value\": null } ] } ], \"scan_id\": \"console\", \"severity_counters\": { \"HIGH\": 0, \"INFO\": 0, \"LOW\": 0, \"MEDIUM\": 1 }, \"total_counter\": 1 }","title":"Results"},{"location":"results/#results","text":"KICS results are output in clear and simple JSON format. Example: { \"files_scanned\": 2, \"files_parsed\": 2, \"files_failed_to_scan\": 0, \"queries_total\": 253, \"queries_failed_to_execute\": 0, \"queries_failed_to_compute_similarity_id\": 0, \"queries\": [ { \"query_name\": \"Container Allow Privilege Escalation Is True\", \"query_id\": \"c878abb4-cca5-4724-92b9-289be68bd47c\", \"severity\": \"MEDIUM\", \"platform\": \"Terraform\", \"files\": [ { \"file_name\": \"assets/queries/terraform/kubernetes_pod/container_allow_privilege_escalation_is_true/test/positive.tf\", \"similarity_id\": \"063ed2389809f5f01ff420b63634700a9545c5e5130a6506568f925cdb0f8e13\", \"line\": 11, \"issue_type\": \"IncorrectValue\", \"search_key\": \"kubernetes_pod[test3].spec.container.allow_privilege_escalation\", \"search_value\": \"\", \"expected_value\": \"Attribute 'allow_privilege_escalation' is undefined or false\", \"actual_value\": \"Attribute 'allow_privilege_escalation' is true\", \"value\": null } ] } ], \"scan_id\": \"console\", \"severity_counters\": { \"HIGH\": 0, \"INFO\": 0, \"LOW\": 0, \"MEDIUM\": 1 }, \"total_counter\": 1 }","title":"Results"},{"location":"roadmap/","text":"KICS Roadmap Status Milestone ETA Target Release Not-Started Milestone 6 Apr 2021 Helm support TBA Schemas support OpenAPI TBA Schemas support Swagger TBA Distribution platforms: Homebrew, Chocolatey TBA In-Progress Milestone 5 Mar 2021 In-Progress Terraform - Parameters files support v1.3.0 In-Progress Reporting - add HTML format v1.2.0 In-Progress Milestone 4 Feb 2021 In-Progress Reporting - add SARIF format v1.2.0 In-Progress Improved CLI outputs (progess, coloring, logo) v1.2.0 In-Progress Engineering and performance improvements 1.2.0 Completed CI/CD improved documentation v1.1.4 Completed Mac support v1.1.3 Completed Hard-coded secret keys detection v1.1.3 Closed Milestones Status Milestone ETA Release Completed Milestone 3 January 2021 Adding more queries and extending coverage v1.1.1 Adding more CI/CD integrations v1.1.1 Engineering and performance improvements v1.1.1 Completed Milestone 2 December 2020 Adding support for K8S v1.1.0 Adding support for Docker v1.1.0 Adding support for Ansible v1.1.0 Adding support for AWS CloudFormation v1.1.0 Designing official logo for KICS Completed Milestone 1 November 2020 First version of KICS engine v1.0.0 Terraform support, 50 queries v1.0.0 Delivery: CLI & Docker v1.0.0 Have an idea? Join the chat on Gitter . Or contact KICS core team at kics@checkmarx.com","title":"Roadmap"},{"location":"roadmap/#kics-roadmap","text":"Status Milestone ETA Target Release Not-Started Milestone 6 Apr 2021 Helm support TBA Schemas support OpenAPI TBA Schemas support Swagger TBA Distribution platforms: Homebrew, Chocolatey TBA In-Progress Milestone 5 Mar 2021 In-Progress Terraform - Parameters files support v1.3.0 In-Progress Reporting - add HTML format v1.2.0 In-Progress Milestone 4 Feb 2021 In-Progress Reporting - add SARIF format v1.2.0 In-Progress Improved CLI outputs (progess, coloring, logo) v1.2.0 In-Progress Engineering and performance improvements 1.2.0 Completed CI/CD improved documentation v1.1.4 Completed Mac support v1.1.3 Completed Hard-coded secret keys detection v1.1.3","title":"KICS Roadmap"},{"location":"roadmap/#closed-milestones","text":"Status Milestone ETA Release Completed Milestone 3 January 2021 Adding more queries and extending coverage v1.1.1 Adding more CI/CD integrations v1.1.1 Engineering and performance improvements v1.1.1 Completed Milestone 2 December 2020 Adding support for K8S v1.1.0 Adding support for Docker v1.1.0 Adding support for Ansible v1.1.0 Adding support for AWS CloudFormation v1.1.0 Designing official logo for KICS Completed Milestone 1 November 2020 First version of KICS engine v1.0.0 Terraform support, 50 queries v1.0.0 Delivery: CLI & Docker v1.0.0 Have an idea? Join the chat on Gitter . Or contact KICS core team at kics@checkmarx.com","title":"Closed Milestones"},{"location":"img/logo/logo/","text":"Placeholder for all KICS logos","title":"Logo"}]}